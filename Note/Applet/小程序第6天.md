## 黑马优购



### 今日目标



### 1. 头像昵称填写

关于小程序用户昵称和头像的获取，小程序官方做过[多次调整](https://developers.weixin.qq.com/community/develop/doc/00022c683e8a80b29bed2142b56c01)，目前最新的方式是由用户主动填写的方式获取。

重要：该功能是新增的需求，因此页面需要有一些调整，将原来的页面路径 `subpkg/pages/auth` 更换成 `subpkg/pages/profile` ，除了改文件名称外，还要更改 `pages.json` 中分包的路径。

#### 1.1 用户头像

通过为 [button](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)组件指定 `open-type="chooseAvatar"` 来设置用户头像，同时监听`button` 组件的  `chooseavatar` 事件，在事件回调中可以获取用户设置头像的地址：

```xml
<!-- subpkg/pages/profile.vue -->
<button class="avatar-wrapper" open-type="chooseAvatar" @chooseavatar="onChooseAvatar">
  <image class="avatar" :src="userProfile.avatarUrl"></image>
</button>
```

```javascript
// subpkg/pages/profile.vue
export default {
  data() {
    return {
      userProfile: {
        avatarUrl: ''
      }
    }
  },
  methods: {
    onChooseAvatar(ev) {
      // 获取头像地址
      this.userProfile.avatarUrl = ev.detail.avatarUrl;
    }
  }
}
```

#### 1.2 用户昵称

通过为 `input` 组件指定 `type="nickname"` 能够将默认的用户昵称调出来实现自动填写，用户也可以在 `input` 中自定义填写：

```xml
<!-- subpkg/pages/profile.vue -->    
<view class="nickname-wrapper">
  <label for="">昵称:</label>
  <input
  	type="nickname"
    :value="userProfile.nickName"
    @blur="onBlurNickName"
    placeholder="请输入昵称" />
</view>
```

为了即时获取用户填写的昵称，我们监听 `input` 组件的 `blur` 事件（根据需要也可监听其它事件，如 input 事件、confirm 事件等）

```javascript
// subpkg/pages/profile.vue
export default {
  data() {
    return {
      userProfile: {
        avatarUrl: '',
        nickName: ''
      }
    }
  },
  methods: {
    chooseavatar(ev) {
      // 获取头像地址
      this.userProfile.avatarUrl = ev.detail.avatarUrl;
    },
    onBlurNickName(ev) {
      this.userProfile.nickName = ev.detail.value
    }
  }
}
```

以上便是新增加的用户昵称和头像填写功能的用法了，下面将该功能整合到黑马优购当中。

#### 1.3 Vuex存储

一般用户昵称和头像填写功能获取到的用户头像要发送给服务端存入数据库，但是目前黑马优购还没有开发相应的接口，因此咱们可以先将其存入 Vuex 和本地存储当中：

在 Vuex 的 `user` 模块中增加一个状态数据 `userProfile` 并添加一个方法 `saveProfile` 来保存记录这个状态数据：

```javascript
// store/user.js
export default {
  namespaced: true,
  state() {
    return {
      address: uni.getStorageSync('address') || null,
      // userProfile 上节课就添加了（这里补充了默认值）
      userProfile: uni.getStorageSync('userProfile') || {
        avatarUrl: 'https://mmbiz.qpic.cn/mmbiz/icTdbqWNOwNRna42FI242Lcia07jQodd2FJGIYQfG0LAJGFxM4FbnQP6yfMxBgJ0F3YRqJCJ1aPAK2dQagdusBZg/0',
        nickName: '微信用户'
      }
    }
  },
  getters: {
    // 这个 userInfo 不需要了，要删除掉！！！
    userInfo(state) {
      return state.userInfo;
    }
  },
  mutations: {
    saveAddress(state, address) {},
    // 该方法上节课就已经添加好了
    saveProfile(state, userProfile) {
      // 记录到 vuex 中
      state.userProfile = userProfile;
      // 存入本地
      uni.setStorageSync('userProfile', userProfile)
    },
  }
}
```

#### 1.4 修改保存返回

```javascript
export default {
	computed: {
		...mapState('user', ['userProfile'])
	},
	methods: {
		chooseavatar(e) {
			console.log(e.detail);
			const { avatarUrl } = e.detail;
			this.userProfile.avatarUrl = avatarUrl;
		},
		onBlurNickName(e) {
			console.log(e.detail);
			this.userProfile.nickName = e.detail.value;
		},
    // 保存修改
		saveProfile() {
			this.$store.commit('user/saveProfile', this.userProfile);
			// 保存后返回去
			uni.navigateBack();
		}
	}
};
```

重要：最后来对上节课【我的】页面中展示用户头像和昵称的逻辑做些调整：

```xml
<!-- pages/center/index.vue -->
<view class="profile">
  <view class="meta">
    <image class="avatar" :src="userProfile.avatarUrl"></image>
    <text class="nickname">{{ userProfile.nickName }}</text>
  </view>
</view>
<!-- 中间省略了部分代码... -->
<view class="extra">
  <!-- 看这里... -->
  <view class="item icon-arrow" @click="makePhone">联系客服</view>
  <button class="item icon-arrow" open-type="feedback">意见反馈</button>
  <button class="item icon-arrow" @click="setProfile">修改个人信息</button>
</view>
```

```javascript
// pages/cart/index.vue
import { mapState } from 'vuex';
export default {
  computed: {
    ...mapState('user', ['userProfile']),
    // 这一行代码不需要了（删掉）
    ...mapGetters('user', ['userInfo'])
  },
  methods: {
    makePhone() {
      uni.makePhoneCall({
        phoneNumber: '10086'
      });
    },
    // 跳转到昵称和头像填写页面
    setProfile() {
      uni.navigateTo({
        url: '/subpkg/pages/profile/index'
      });
    }
  }
};
```

功能逻辑编写完毕后提交 `git`

```bash
# 查看修改状态
git status
# 提交代码
git add .
git commit -m '完成用户头像和昵称填写功能'
# 推送分支到远程仓库
git push origin feature-center
```


### 2. 小程序登录

当用户准备购买商品时要求用户必须是处于登录状态，我们来学习在微信小程序如何实现登录功能。

传统的登录实现方式是通过提交表单的方式实现：先给用户提供一个表单，用户在表单填写登录信息后提交表单验证用户的信息是否正确。

在小程序中可以将登录的流程进行简化：通过调用 API 的形式方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系，从而实现登陆功能,下图需要前后端配合一起来完成，大家暂时先有个了解即可。



![](./images/api-login.jpg)



```bash
# 切换到 main 分支
git checkout main
# 切换并创建分支
git checkout -b feature-login
```

#### 1.1 登录凭证

调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户在当前小程序的唯一标识（openid）、微信开放平台帐号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台帐号）及本次登录的会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。

实现小程序用户体系主要涉及到`openid`和`code`的概念：

- 调用`wx.login()`方法会生成`code`，将`code`作为参数传递给微信服务器指定接口，就可以获取用户的`openid`

对于每个小程序，微信都会将用户的微信`ID`映射出一个小程序 `openid`，作为这个用户在这个小程序的唯一标识

在上图中可以看到实现登录的第一步是调用 `wx.login` 用来获取登录凭证（一个名称为 `code` 的字符串）：

```javascript
// wx.login() 在 uni-app 中使用 uni.login()
// 在 App.vue 中测试这个 API 的使用
export default {
  async onShow() {
    // 解构方式获得 code
    const [err, { code }] = await uni.login();
    // 这便是登录凭证了
    console.log(code);
  }
}
```

#### 1.2 用户信息

获取用户信息的方式有点“乱”，最新的调整是使用 `wx.getUserInfo` 来获取且无需用户授权，也不要求用户必须点击按钮。

注：`wx.getUserProfile` 本来是要替换 `wx.getUserInfo` 的，结果 `wx.getUserProfile` 反到即将被回收（废弃）详细见[公告说明](https://developers.weixin.qq.com/community/develop/doc/00022c683e8a80b29bed2142b56c01)，和另一个[公告说明](https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801)。

```javascript
// 在 App.vue 中测试这个 API 的使用
export default {
  async onShow() {
    // 解构方式获得 code
    const [err, { code }] = await uni.login();
    // 这便是登录凭证了
    console.log(code);
    
    // 获取用户信息
    const [err1, userInfo] = await uni.getUserInfo();
    // 用户信息中加密处理的，需要通过 code 及其它信息将它解开
    console.log(userInfo);
  }
}
```

#### 1.3 获取 Token

由于 `wx.login` 和 `wx.getUserInfo` 可以直接被调用，由此可以在用户无感知的情况实现登录的功能。在小程序启动的时候，将获取的到的 `code` 及 `userInfo` 发送到服务端（调用接口）换取 Token 实现用户登录的功能。

```javascript
// App.vue
import { mapState } from 'vuex';
export default {
  computed: {
    ...mapState('user', ['token'])
  },
  onLaunch() {},
  onShow() {
    // 在用户未登录的情况下获取 Token
    if(!token) this.$store.dispatch('user/getToken');
  }
}
```

将获取 token 的逻辑封装到 Vuex 中

```javascript
// store/user.js
export default {
  namespaced: true,
  state() {
    return {
      address: uni.getStorageSync('address') || null,
      userProfile: uni.getStorageSync('userProfile') || {
        avatarUrl: 'https://mmbiz.qpic.cn/mmbiz/icTdbqWNOwNRna42FI242Lcia07jQodd2FJGIYQfG0LAJGFxM4FbnQP6yfMxBgJ0F3YRqJCJ1aPAK2dQagdusBZg/0',
        nickname: '微信用户'
      },
      // 初始token
      token: uni.getStorageSync('token') || ''
    }
  },
  mutations: {
    saveAddress(state, address) {},
    saveProfile(state, userProfile) {},
    // 记录获取到的 token
    saveToken(state, token) {
      state.token = token;
      // 存入本地
      uni.setStorageSync('token', token);
    }
  },
  actions: {
    async getToken() {
      // 获取登录凭证
      const [err1, {code}] = await uni.login();
      // 获取用户信息
      const [err2, {rawData, signature, iv, encryptedData}] = await uni.getUserInfo();
      // 调用接口获取 Token 只有老师的权限"appid": "wxfb52f2d7b2f6123a",同学们无法使用，无需替换！！！
      const { data: res } = await uni.$http.post('/api/public/v1/users/wxlogin', {
        code,
        rawData,
        signature,
        iv,
        encryptedData
      })
      // 记录保存token
      if(res.message.token) this.commit('user/saveToken', res.message.token);
    }
  }
}
```

功能逻辑完成后提交 `git`

```bash
# 查看修改状态
git status
# 提交修改
git add .
git commit -m '获取用户登录token'

# 推送到远程分支
git push origin feature-login
```

#### 1.4 请求拦截

在请求拦截器中将 `token` 添加到请求头信息 `header` 当中，只要有请求时自动发送给服务端接口。

注：黑马优购的接口有一个规范，如果请求路径中包含了 `/my/` 则该接口是要求必须发送 `token` ，相反则不必发送 `token`。

```javascript
// utils/http.js
import {
  $http
} from '@escook/request-miniprogram';

// 导入vuex
import store from '@/store/store';

// 配置接口的基础路径
$http.baseUrl = 'https://api-hmugo-web.itheima.net';

// 配置请求前要执行的操作
$http.beforeRequest = function(options) {
  // 加载提示
  uni.showLoading({
    title: '正在加载...',
    mask: true
  });
  
  // 只有路径中包含了 /my/ 的才需要发送 token
  if(options.url.includes('/my/')) {
    options.header = {
      Authorization: store.state.user.token;
    }
  }
}

// 配置请求后要执行的操作
$http.afterRequest = function() {
  // 隐藏加载提示
  uni.hideLoading()
}

// 思考 uni-app 中哪个对象是全局的？
// 答：uni

uni.$http = $http;
```

功能逻辑完成后提交 `git`

```bash
# 查看修改状态
git status
# 提交修改
git add .
git commit -m '添求拦截设置token'

# 推送到远程分支
git push origin feature-login

# 合并到 main 分支
git checkout main
git merge feature-login
```

### 3. 订单

在购物车和商品详情中用户可以完成对商品的购买，购买过程是由创建订单和微信支付两部分构成。

```bash
# 切换到 main 分支
git checkout main
# 创建并切换分支
git checkout -b feature-order
```

#### 4.1 创建订单

在购物车页面中用户点击【结算】按钮后调用接口来创建订单，在调用接口之前需要对提交的数据进行验证：

```xml
<!-- pages/cart/index.vue -->
<view class="extra">
  <label class="checkall" @click="toggleAll">
    <icon type="success" :color="allChecked ? '#ea4451' : '#ccc'" size="20"></icon>
    全选
  </label>
  <view class="total">
    合计:
    <text>￥</text>
    <label>{{ amount }}</label>
    <text>.00</text>
  </view>
  <!-- 看这里... -->
  <view class="pay" @click="goPayment">结算({{ checkedCount }})</view>
</view>
```
1. 验证待购买的商品

```javascript
// pages/cart/index.vue
import { mapState, mapGetters } from 'vuex';
export default {
  computed: {
    // ... 省略部分代码
    goods() {
      // 只需要处于选中状态的商品
      return this.carts.filter(item => item.goods_state)
    }
  },
  methods: {
    // ...省略了部分代码
    
    // 创建订单
    createOrder() {
      // 验证购买的商品
      if(this.goods.length === 0) {
        return uni.showToast({
          title: '没有选中任何商品!',
          icon: 'none'
        })
      }
      
      // 验证收货地址
      
    },
    async goPayment() {
      await this.createOrder()
    }
  }
};
```

2. 验证收货地址

```javascript
// store/user.js
export default {
  namespaced: true,
  state() {
    return {
      address: uni.getStorageSync('address') || null,
			// ... 省略部分代码
    }
  },
  getters: {
    // 看这里是新增加的
    fullAddress(state) {
      if(!state.address) return '';
      const {provinceName, cityName, countyName, detailInfo} = state.address;
      // 拼凑完整的地址
      return provinceName + cityName + countyName + detailInfo;
    }
  },
  mutations: {
    saveAddress(state, address) {},
    saveProfile(state, userProfile) {}
  }
}
```

```javascript
// pages/cart/index.vue
import { mapState, mapGetters } from 'vuex';
export default {
  computed: {
    // ... 省略部分代码
    ...mapGetters('user', ['fullAddress']),
    goods() {
      // 只需要处于选中状态的商品
      return this.carts.filter(item => item.goods_state)
    },
    // 为了生成订单获取完整的地址
		fullAddress() {
			if (!this.address) {
				return '';
			}
			const { provinceName, cityName, countyName, detailInfo } = this.address;
			return provinceName + cityName + countyName + detailInfo;
		}
  },
  methods: {
    // ...省略了部分代码
    
    // 创建订单
    createOrder() {
      // 验证购买的商品
      if(this.goods.length === 0) {
        return uni.showToast({
          title: '没有选中任何商品!',
          icon: 'none'
        })
      }
      
      // 验证收货地址
      if(!this.fullAddress) {
        return uni.showToast({
          title: '请先添加收货地址',
          icon: 'none'
        })
      }
    },
    async goPayment() {
      await this.createOrder()
    }
  }
};
```

3. 调用接口创建新订单

```javascript
// pages/cart/index.vue
import { mapState, mapGetters } from 'vuex';
export default {
  data() {
    return {
      order_number: ''
    }
  },
  computed: {
    // ... 省略部分代码
    ...mapGetters('cart', ['allChecked', 'checkedCount', 'amount'])
    ...mapGetters('user', ['fullAddress']),
    goods() {
      // 只需要处于选中状态的商品
      return this.carts.filter(item => item.goods_state)
    }
  },
  methods: {
    // ...省略了部分代码
    
    // 创建订单
    createOrder() {
      // 验证购买的商品
      if(this.goods.length === 0) {
        return uni.showToast({
          title: '没有选中任何商品!'
        })
      }
      // 验证收货地址
      if(!this.fullAddress) {
        return uni.showToast({
          title: '请先添加收货地址',
          icon: 'none'
        })
      }
      // 调用接口生成新订单
      const {data: res} = uni.$http.post('/api/public/v1/my/orders/create', {
        order_price: this.amount,
        consignee_addr: this.fullAddress,
        goods: this.goods
      });
      // 验证是否创建订单成功
      if(res.meta.status === 200) this.order_number = res.message.order_number;
    },
    async goPayment() {
      // 等待订单创建完成
      await this.createOrder();
      // 是否创建成功待付订单
      if(!this.order_number) {
        return uni.showToast({
          title: '订单是创建失败!',
          icon: 'none'
        })
      }
    }
  }
};
```

#### 4.2 微信支付

微信支付流程介绍

<img src="images/image-20220708210154566.png" alt="image-20220708210154566" style="zoom: 50%;" />

在了解了支付的流程后调用小程序的 API [uni.requestPayment](https://uniapp.dcloud.io/api/plugins/payment.html#requestpayment) 即可唤起支付窗口引导用户进行支付，但是 `uni.requestPayment` 所需要的参数需要由后端返回。

```javascript
// pages/cart/index.vue
import { mapState, mapGetters } from 'vuex';
export default {
  data() {
    return {
      order_number: 0
    }
  },
  computed: {
    // ... 省略部分代码
    ...mapGetters('cart', ['allChecked', 'checkedCount', 'amount'])
    ...mapGetters('user', ['fullAddress']),
    goods() {
      // 只需要处于选中状态的商品
      return this.carts.filter(item => item.goods_state)
    }
  },
  methods: {
    // ...省略了部分代码
    
    // 创建订单
    createOrder() {},
    // 微信支付
    async goPayment() {
      // 等待订单创建完成
      await this.createOrder();
      // 是否创建成功待付订单
      if(!this.order_number) {
        return uni.showToast({
          title: '订单是创建失败!',
          icon: 'none'
        })
      }
      // 调用后端接口获取 uni.requestPayment 所需要的参数
      const {data: res} = await uni.$http.post('/api/public/v1/my/orders/req_unifiedorder', {
        order_number: this.order_number
      });
      
      if(res.meta.status !== 200) {
        return uni.showToast({
          title: '支付参数错误!',
          icon: 'none'
        })
      }
      // 调用 uni.requestPayment
      uni.requestPayment({
        ...res.message.pay,
        complete() {
          // 支付成功
          uni.navigateTo({
            url: '/subpkg/pages/order/index'
          })
        }
      })
    }
  }
};
```

#### 4.3 订单列表

留成作业自行完成
### 4. 打包发布

在首页面中使用 `search` 组件的交互代码中有一个小 `bug` ，现更正一下：

```javascript
// pages/index/index.vue
export default {
  data() {
    return {
      // ...
    }
  },
  methods: {
    disableScroll(ev) {
      // 原来写法是这样的
      // this.pageHeight = ev.pageHeight + 'px';
      // 更正后是这样的
      this.pageHeight = ev.pageHeight;
    },
    // ... 省略后面代码
  }
}
```

 然后在 `search` 组件也要稍微修改一下：

```javascript
// components/search/index.vue
export default {
  data() {
    return {
      // ...
    }
  },
  methods: {
    goSearch(ev) {
      this.focused = true;
      this.placeholder = '请输入您要搜索的内容';

      // 触发父组件自定义事件
      this.$emit('search', {
        // 原来代码是这个样子的
        // pageHeight: uni.getSystemInfoSync().windowHeight;
        // 现在改成这个样子
        pageHeight: uni.getSystemInfoSync().windowHeight + 'px';
      });

      // 隐藏tabBar
      uni.hideTabBar();
    },
    // ...省略后面代码
  }
}
```

附：打包到 H5 时 Vant 组件报错的[解决方法](https://blog.csdn.net/weixin_45977625/article/details/122480131)。

```bash
# 切换到 main 分支
git checkout main
# 创建并切换分支
git checkout -b feature-build
```

#### 2.1 条件编译

通过 uni-app 可以实现跨平台的开发，然页不同的平台具有不同的特性，不可能完全实现一套代码适应多个平台，为了解决不同平台的差异所带来的问题 uni-app 提供了条件编译的功能。

[条件编译](https://uniapp.dcloud.io/tutorial/platform.html)是用特殊的**注释**作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。

快速体验：在购物车页面调用 `uni.chooseAddress` 来获取用户的[收货地址](https://uniapp.dcloud.io/api/other/choose-address.html#chooseaddress)，然后如果在 H5（移动 Web）中是无法使用这个方法的，此时我们就可以通过条件编译来处理：

```xml
<!-- pages/cart/index.vue -->
<van-button block type="primary" @click="saveAddress" v-else>获取收货地址</van-button>
```

```javascript
export default {
  // ...省略其它步骤
  methods: {
		async saveAddress() {
      // #ifndef MP-WEIXIN
      uni.showToast({
        title: '仅在小程有效!'
      });
      // #endif

      // #ifdef MP-WEIXIN
      // 获取用户的收货地址
      const [err, { errMsg, ...address }] = await uni.chooseAddress();
      // 调用 mutitations 来保存收货地址
      this.$store.commit('user/saveAddress', address);
      // #endif
    },
  }
}
```

`#ifdef` 和 `#endif` 表示肯定，`#ifndef` 和 `#endif` 表示否定，除了在 `javascript` 中使用条件编译外，在模板和样式中也可以使用条件编译：

- 组件模板中使用

```xml
<!-- #ifdef H5 -->
<view>这里随便写会组件都可以...</view>
<!-- #endif -->
```

- 样式中使用

```css
/* #ifdef MP-WEIXIN */
/* 任何合法的 css */
.box {
  width: 100rpx;
  color: red;
}
/* #endif */
```

注：所有可用的平台名称在使用时请[查看文档](https://uniapp.dcloud.io/tutorial/platform.html#preprocessor)

#### 2.2 小程序发布

在 HBuilderX 中顶部菜单依次点击 "发行" => "小程序-微信"，输入小程序名称和 AppID 点击发行即可在 `unpackage/dist/build/mp-weixin` 生成微信小程序项目代码；

![image-20220719083429665](images/image-20220719083429665.png)

#### 2.3 云打包

云打包功能是 uni-app 专门提供的用于生成 android 和 ios 应用的服务，在使用该项服务前请务必[注册uni-app](https://dev.dcloud.net.cn/)开发者账号并进行实名认证。

1. 获取 uni-app 平台提供的应用 ID

![](./images/img-1.png)

除了配置就用 ID 外还可配置应用 logo、系统权限等。

2. 云打包参数设定

![](./images/img-2.png)

包名要求有特定的格式、证书使用云端证书、打包方式选择快速安心打包。

3. 打包过程会安装一些插件并检测各种合法性，按提示完成操作后重新打包即可

![](./images/img-3.png)

![](./images/img-5.png)

4. 耐心等待，不要重复打包

![](./images/img-6.png)

功能逻辑完成后提交 `git`

```bash
# 查看修改状态
git status
# 提交
git add .
git commit -m '跨平台兼容处理及云打包'
# 推送到远程仓库
git push origin feature-build
```
### 5. 其它

上传小程序忽略无用的文件，如图片等。

在 manifest.json 中进行设置：

```json
	/* 微信小程序特有相关 */
		"appid": "wxfb52f2d7b2f6123a",
		/* packOptions 的 ignore 字段中手动将被忽略的文件引入*/
		"packOptions": {
			"ignore": [{
					"type": "folder",
					"value": "static/uploads"
				},
				{
					"type": "folder",
					"value": "static/images"
				}
			]
		},
```

![](./images/img-7.png)



uniapp 环境变量 process.env.NODE_ENV

自基础库版本`2.11.1`起，微信小程序支持有选择地注入必要的代码，以降低小程序的启动时间和运行时内存

```json
{
  "lazyCodeLoading": "requiredComponents"
}
```

`custom` 自定义导航栏

```json
{
  "navigationStyle": "custom"
}
```

[uni.createSelectorQuery()](https://uniapp.dcloud.io/api/ui/nodes-info.html#createselectorquery)

返回一个 `SelectorQuery` 对象实例。可以在这个实例上使用 `select` 等方法选择节点，并使用 `boundingClientRect` 等方法选择需要查询的信息。

**Tips:**

- 使用 `uni.createSelectorQuery()` 需要在生命周期 `mounted` 后进行调用。
- 默认需要使用到 `selectorQuery.in` 方法

```javascript
// 小程序
const query = wx.createSelectorQuery()
query.select('#the-id').boundingClientRect()
query.selectViewport().scrollOffset()
query.exec(function(res){
  res[0].top       // #the-id节点的上边界坐标
  res[1].scrollTop // 显示区域的竖直滚动位置
})
// uni-app
const query = uni.createSelectorQuery().in(this);
query.select('#id').boundingClientRect(data => {
  console.log("得到布局位置信息" + JSON.stringify(data));
  console.log("节点离页面顶部的距离为" + data.top);
}).exec();
```

