# 极客园H5项目【登录模块】

## 01-基本结构

**目标**：能够手动搭建登录界面的基本结构

**分析说明**：antd-mobile 中的 Form 组件用法与 antd 一样

**步骤**：

1. 完成导航栏和登录标题 - [NavBar 组件](https://mobile.ant.design/zh/components/nav-bar)
2. 添加登录表单 - [Form 组件](https://mobile.ant.design/zh/components/form)

**核心代码**：

login/index.tsx 中：

```tsx
import { Button, NavBar, Form, Input } from 'antd-mobile'

import styles from './index.module.scss'

const Login = () => {
  return (
    <div className={styles.root}>
      <NavBar></NavBar>

      <div className="login-form">
        <h2 className="title">账号登录</h2>

        <Form>
          <Form.Item className="login-item">
            <Input placeholder="请输入手机号" />
          </Form.Item>

          <Form.Item
            className="login-item"
            extra={<span className="code-extra">发送验证码</span>}
          >
            <Input placeholder="请输入验证码" autoComplete="off" />
          </Form.Item>

          {/* noStyle 表示不提供 Form.Item 自带的样式 */}
          <Form.Item noStyle>
            <Button
              block
              type="submit"
              color="primary"
              className="login-submit"
            >
              登 录
            </Button>
          </Form.Item>
        </Form>
      </div>
    </div>
  )
}

export default Login
```

login/index.module.scss 中：

```scss
// 导入 1px 边框的样式文件
@import '@scss/hairline.scss';

.root {
  :global {
    .login-form {
      padding: 0 33px;

      .title {
        margin: 54px 0 13px 0;
      }

      .adm-list {
        --align-items: end !important;
      }
      .adm-list-default {
        border: none;
      }
      .adm-list-item {
        padding: 0;
      }
      .login-item {
        // 注意：因为 1px 边框样式使用了决定定位，所以，此处需要将设置为相对定位
        position: relative;
        // 为该元素设置 1px 边框
        @include hairline(bottom, #f0f0f0);

        > .adm-list-item-content {
          height: 70px;
        }
      }
      .adm-list-item-content {
        position: relative;
        border-bottom: none;
      }
      // 验证码
      .adm-input-wrapper {
        --placeholder-color: #a5a6ab;
      }
      .code-extra {
        display: inline-block;
        height: 50px;
        line-height: 50px;
        color: #595769;
        font-size: 14px;

        &-disabled {
          color: #a5a6ab;
        }
      }
      .adm-list-item-description {
        position: absolute;
        z-index: 1;
        bottom: -25px;
      }

      .login-submit {
        height: 50px;
        margin-top: 38px;
        border: none;
        font-size: 16px;
        background: linear-gradient(315deg, #fe4f4f, #fc6627);
      }
    }
  }
}
```

## 02-表单校验

**目标**：能够为登录表单添加校验

**核心代码**：

login/index.tsx 中：

```tsx

<Form validateTrigger={['onBlur']}>
  {/*
  	name 表单提交时的名称
  	validateTrigger 触发表单校验的时机，每一个表单项的 validateTrigger 必须是 Form 的 validateTrigger 的其中一个
  	rules 表单校验规则
  */}
  <Form.Item
    name="mobile"
    validateTrigger="onBlur"
    rules={[
      { required: true, message: '请输入手机号' },
      {
        pattern: /^1[3-9]\d{9}$/,
        message: '手机号格式错误'
      }
    ]}
  ></Form.Item>

  <Form.Item
    name="code"
    rules={[{ required: true, message: '请输入验证码' }]}"
    validateTrigger="onBlur"
  ></Form.Item>
</Form>
```

**总结**：

- 注意：不要忘记给每个需要校验的 Form.Item 添加 name 属性

## 03-获取登录表单数据

**目标**：能够拿到手机号和验证码数据

**步骤**：

1. 为 Form 表单添加 `onFinish`
2. 创建 onFinish 函数，作为 Form 属性 `onFinish` 的值
3. 指定函数 onFinish 的参数类型
4. 通过参数获取到表单数据

**核心代码**：

login/index.tsx 中：

```tsx
type LoginForm = {
  mobile: string
  code: string
}
const Login = () => {
  const onFinish = (values: LoginForm) => {
    console.log(values)
  }

  return (
    <Form onFinish={onFinish}></Form>
  )
}
```

## 04-默认登录-登录逻辑

**目标**：能够在Redux中实现登录逻辑

**分析说明**：

实际项目开发中，通常都会为接口数据创建类型，这样，如果将来后端修改了接口数据，前端只需要修改接口数据的类型，

然后，所有用到该数据的地方都会有明确的错误提示，根据错误提示来进行修改即可。有利于项目功能的修改或重构

推荐按照以下步骤：

1. 先按照接口的返回数据，准备 TS 类型
2. 然后，在发送请求时，指定该请求的返回值类型

这样，在接下来的操作中，如果需要用到接口的数据，都会有类型提示了。

由于项目中的请求是通过 axios 处理的，所以，只需要为 axios 的请求方法指定类型即可：

- axios 的所有请求方法，都是泛型函数，通过泛型函数的泛型参数，来指定接口返回数据的类型
- 从哪获取 接口返回数据 的类型？文档

```ts
// 比如，以 post 请求为例：
const res = await axios.post<ResponseDataType>()

// res.data 的类型就是：ResponseDataType
```

**步骤**：

1. 在 store/slices/login，创建 login 函数并导出
3. 在函数中根据接口发送请求实现登录功能
5. 在 login slice 的 extraReducers 中处理 login action

**核心代码**：

store/slices/login.ts 中：

```ts
// 创建 登录 的 action
type LoginParams = {
  mobile: string
  code: string
}

export const login = createAsyncThunk(
  'login/login',
  async (data: LoginParams) => {
    // 发送请求
    const res = await http.post<LoginResponse>('/authorizations', data)
    // 拿到返回数据
    const { data: token } = res.data
    // 将 token 数据存储到本地缓存中
    setToken(token)
    // 返回 token，方便后续操作
    return token
  }
)
```

```ts
const loginSlice = createSlice({
	// ...
  extraReducers: builder => {
    // 处理登录后，获取到到的 token 状态
    builder.addCase(login.fulfilled, (state, action) => {
      // 返回 token 值，该值会赋值 login 对应的状态值
      return action.payload
    })
  },
})
```

## 05-默认登录-组件登录逻辑

**目标**：能够调用登录逻辑实现登录并跳转到首页

**步骤**：

1. 在 Login 组件中导入登录 action
2. 在表单提交时，分发登录 action
3. 登录成功后，展示成功提示
4. 跳转到首页

**核心代码**：

pages/Login/index.tsx 中：

```tsx
import { Toast } from 'antd-mobile'
import { useNavigate } from 'react-router-dom'
import { login } from '@/store/actions'

const Login = () => {
  const dispatch = useAppDispatch()
  const navigate = useNavigate()

  const onFinish = async (values: LoginForm) => {
    await dispatch(login(values))

    // 登录成功提示
    Toast.show({
      content: '登录成功',
      duration: 600,
      afterClose: () => {
        // 返回首页
        navigate('/home', { replace: true })
      }
    })
  }
}
```

## 06-默认登录-异常处理

**目标**：能够处理登录时的异常

**分析说明**：

可以通过 `try...catch` 进行异常处理，其中 catch 的错误对象 `e` 的类型是：`unknown`

因此，要根据错误对象 e 进行异常处理，就需要先明确指定其类型，然后，才能对错误对象 e 进行操作

```ts
try {
  // ...
} catch (e) {
  // e => unknown
  const error = e as 具体的错误类型
}
```

**核心代码**：

pages/Login/index.tsx 中：

```tsx
import { AxiosError } from 'axios'

const onFinsih = async (values: LoginForm) => {
  try {
    await dispatch(login(values))
    // 成功
    Toast.show({
      content: '登录成功',
      duration: 600,
      afterClose: () => {
        history.replace('/home')
      }
    })
  } catch (e) {
    // 异常
    // 如果异步操作失败了，会执行此处的错误处理
    // 对于登录功能来说，出错了，通常是请求出问题了。
    // 因此，此处将错误类型转为 AxiosError
    const error = e as AxiosError<{ message: string }>
    Toast.show({
      content: error.response?.data?.message,
      duration: 1000
    })
  }
}
```

## 07-默认登录-redux获取token

**目标**：能够实现刷新页面时在redux状态中拿到token

**分析说明**：

问题：登录成功后，redux 状态中有 token 值。但是，刷新页面后，redux 中的 token 值没有了

原因说明：只在登录时，将 token 存储到 redux 状态中，没有处理刷新的情况

有两种方式实现该功能：

1. 获取本地存储中的 token，设置为 login slice 的状态初始值

slices/login.ts 中：

```jsx
const initialState: Token = getToken()
```

utils/token.ts 中：

```ts
export const getToken = () =>
  JSON.parse(
    localStorage.getItem(GEEK_TOKEN_KEY) ??
      '{ "token": "", "refresh_token": "" }'
  ) as Token
```

2. 配置 store 时，设置 login 状态初始值

```ts
const initialState = {
  login: getToken(),
}

const store = configureStore({
  // ...
  
  // 预加载状态，也就是初始状态：
  preloadedState: initialState,
})
```

## 08-登录按钮启用或禁用

**目标**：能够根据表单验证是否成功来启用或禁用登录按钮

**分析说明**：

表单校验成功时，登录按钮为启用

表单校验失败或者用户还没有输入时，登录按钮为禁用

因此，需要动态控制登录按钮的状态，即：在用户输入的时候就进行校验

为了达到该目的，需要用到 `shouldUpdate` 属性，来在表单任意变化都对某一个区域进行渲染，达到实时校验的目的

[参考 antd 文档：Form shouleUpdate](https://ant-design.gitee.io/components/form-cn/#shouldUpdate)
[参考 antd 示例：内联登录栏](https://ant-design.gitee.io/components/form-cn/#components-form-demo-inline-login)

```tsx
// 可以通过 函数形式的children 来自定义渲染内容
<Form.Item noStyle shouldUpdate>
  {() => {
    return (
      <Button
        block
        type="submit"
        color="primary"
        className="login-submit"
      >
        提交
      </Button>
    )
  }}
</Form.Item>
```

**步骤**：

1. 创建登录表单的实例 form，来手动获取 Form 表单的校验状态等
2. 将 form 设置为 Form 组件的 form 属性
3. 使用一个函数的形式来渲染登录按钮
4. 在该函数中处理是否禁用的逻辑
5. 将是否禁用的值设置为 Button 按钮的 disabled 属性

**核心代码**：

```tsx
const Login = () => {
  // 创建 form 实例
  const [form] = Form.useForm()

  return (
    <Form form={form}>
      <Form.Item noStyle shouldUpdate>
        {() => {
          // isFieldsTouched(true) 检查是否所有字段都被操作过
          const untouched = !form.isFieldsTouched(true)
          // getFieldsError() 获取所有字段名对应的错误信息
          const hasError =
            form.getFieldsError().filter(({ errors }) => errors.length)
              .length !== 0
          const disabled = untouched || hasError

          return (
            <Button
              block
              type="submit"
              color="primary"
              className="login-submit"
              disabled={disabled}
            >
              提交
            </Button>
          )
        }}
      </Form.Item>
    </Form>
  )
}

// 上课分析的代码：
<Form.Item noStyle shouldUpdate>
  {() => {
    // isFieldsTouched(true) 用来判断登录表单中的所有表单项是否被操作过
    //  如果都操作过，结果为：true； 否则，为 false
    //  如果只看该判断项，如果为 true 表示操作过，此时，才可能是不禁用
    //                 如果为 false 表示没有操作过（没有输入过内容），就应该是禁用
    // console.log('登录按钮重新渲染了', form.isFieldsTouched(true))
    // console.log(form.getFieldsError())

    // 获取校验失败的表单项
    // const errors = form.getFieldsError().filter(item => item.errors.length > 0)

    // 如果需要获取 表单校验 是否成功，只需要获取上述 errors 数组的长度
    //  如果长度大于 0 说明有错误，表示：表单校验失败；否则，表单校验成功
    // console.log(
    //   form.getFieldsError().filter(item => item.errors.length > 0)
    // )

    // 得到禁用状态
    const disabled =
          form.getFieldsError().filter(item => item.errors.length > 0)
    .length > 0 || !form.isFieldsTouched(true)

    return (
      <Button
        disabled={disabled}
        block
        type="submit"
        color="primary"
        className="login-submit"
        >
        登 录
      </Button>
    )
  }}
</Form.Item>
```

## 09-动态获取验证码-拿到手机号码

**目标**：能够实现点击发送验证码时获取到手机号码

**步骤**：

1. 给发送验证码绑定点击事件
2. 在点击事件中获取到文本框的值
3. 判断文本框的值是否为空
4. 如果为空或手机号格式错误时，让文本框自动获得焦点

**核心代码**：

pages/Login/index.tsx 中：

```tsx
import { useRef } from 'react'
import { InputRef } from 'antd-mobile/es/components/input'

const Login = () => {
  const mobileRef = useRef<InputRef>(null)

  const onGetCode = () => {
    // 拿到手机号
    const mobile = (form.getFieldValue('mobile') ?? '') as string
    // 判断手机号校验是否成功
    const hasError = form.getFieldError('mobile').length > 0
    if (mobile.trim() === '' || hasError) {
      return mobileRef.current?.focus()
    }
  }

  return (
    // ...
    // 鼠标放在 Input 组件的 ref 属性上，可以看到 ref 的类型
    <Input placeholder="请输入手机号" maxLength={11} ref={mobileRef} />
    // ...
    <Form.Item
      className="login-item"
      extra={<span className="code-extra">发送验证码</span>}
    >
      <Input placeholder="请输入验证码" autoComplete="off" />
    </Form.Item>
    // ...
  )
}
```

## 10-动态获取验证码-发送请求

**目标**：能够使用redux发送请求获取验证码

**步骤**：

1. 在 Login 组件中导入获取验证码的 action
2. 在获取验证码事件中分发获取验证码的 action
3. 在 login slices 中创建获取验证码的 action 并导出
4. 发送请求获取验证码

**核心代码**：

pages/Login/index.tsx 中：

```tsx
import { getCode, login } from '@/store/actions'

const onGetCode = () => {
  // ...

  dispatch(getCode(mobile))
}
```

slices/login.ts 中：

```ts
// 获取验证码
export const getCode = createAsyncThunk(
  'login/getCode',
  async (mobile: string) => {
    await http.get(`/sms/codes/${mobile}`)
  }
)
```

## 总结-Form提供的示例方法

Form 中提供的实例方法：[参考 antd 的 Form 组件 API](https://ant-design.gitee.io/components/form-cn/#API)

1. 获取表单中所有表单项的值：`form.getFieldsValue()`
2. 获取表单中某个表单项的值：`form.getFiledValue(name)`
3. 获取表单中所有表单项的错误：`form.getFieldsError()`
4. 获取表单中某个表单项的错误：`form.getFieldError(name)`
5. 手动对表单进行校验并在校验成功时，获取所有表单项的值：`const values = await form.validateFields()`
6. 判断所有表单项是否被操作过（输入过内容）：`form.isFieldsTouched(true)`

```tsx
const [ form ] = Form.useForm()

<Form form={form}>
```

## 11-函数组件的特性与闭包

**目标**：能够理解函数组件的特性与闭包的关系

**内容**：

从一个简单的示例，来看函数组件的特性与闭包：

```jsx
const App = () => {
  const [count, setCount] = useState(0)
  
  const handleClick = () => {
    setCount(count + 1)
  }

  return (
    <div>
      <button onClick={handleClick}>+1</button>
      <h1>计数器：{count}</h1>
    </div>
  )
}
```

函数组件的特性：

**对于 React 的函数组件来说，只要修改状态，组件就会更新。同时，函数中的代码都会从头到尾重新执行一遍。**

也就是说每一次的组件更新，都是一次全新的函数调用，在这一次的调用中都会创建新的：

1. 变量，比如：存储状态的变量 count、普通变量
2. 函数，比如：事件处理程序 handleClick、onSetData、onGetData

需要特殊说明的是：

当一个*函数内部访问了外部的变量时*，由于 **JS 函数闭包机制** 的存在，这个**函数内部只能访问到本次组件更新时创建的变量值**。比如：

组件第一次执行（第一次创建的闭包）：

```jsx
变量 count 的值为：0
函数 handleClick 访问到的外部变量 count 的值就是：0
```

点击 +1 按钮，组件重新渲染，组件第二次执行（第二次创建的闭包）：

```jsx
变量 count 的值为：1
函数 handleClick 访问到的外部变量 count 的值就是：1
```

怎么理解这个过程呢？

**可以把组件的每次更新想象成给组件拍照，组件每次更新都会对应到一张照片，而每一张特定的照片都记录了那一刻组件特定的状态。**

比如：

```tsx
第一张照片（组件第一次执行）中 count 的值为：0
第二张照片（组件更新会后，第二次执行）中 count 的值为：1
```

**从原理层面来看，每一张照片中记录的数据，是每次创建的闭包来保存的**

**总结**：

1. 函数组件状态更新时，组件中的代码会重新执行吗？
2. 组件两次更新中的 handleClick 是同一个函数吗？

## 12-函数组件中的定时器

**目标**：能够使用函数组件的特性分析出定时器打印结果

**内容**：

操作过程如下：

1. 先点击【延迟获取 count 值】按钮
2. 立即点击【+1】按钮 3 次

问题：定时器打印的 count 值为多少？

提示：点击【延迟获取 count 值】按钮，创建定时器时，组件是第几次更新？

```jsx
const App = () => {
  const [count, setCount] = useState(0)
  
  // 3 秒后，获取 count 值
  const getCount = () => {
    setTimeout(() => {
      console.log(count)
    }, 3000)
  }

  // 计数器 +1
  const handleClick = () => {
    setCount(count + 1)
  }
  
  return (
    <div>
      <button onClick={handleClick}>+1</button>
      <button onClick={getCount}>延迟获取 count 值</button>
      <h1>计数器：{count}</h1>
    </div>
  )
}
```

### 清理函数组件中的定时器

**目标**：能够使用 useRef 实现清理定时器功能

**内容**：

问题：这种方式能正确清理定时器吗？

操作过程如下：

1. 先点击【+1】按钮 1 次，让组件重新更新
2. 再点击【清理定时器】按钮

提示分析该问题的出发点：clearInterval 的 timerId 和 useEffect 中的 timerId 是不是同一个？（提示：可以通过打印的方式，查看两处 timerId 的值）

```jsx
const App = () => {
  const [count, setCount] = useState(0)
  let timerId = -1

  useEffect(() => {
    timerId = setInterval(() => {
      console.log('interval')
    }, 1000)
  }, [])

  const clear = () => {
    clearInterval(timerId)
  }

  const handleClick = () => {
    setCount(count + 1)
  }

  return (
    <div>
      <button onClick={handleClick}>+1</button>
      <button onClick={clear}>清理定时器</button>
      <h1>计数器：{count}</h1>
    </div>
  )
}
```

因此，要想在组件更新后清理定时器，就需要让两处的 timerId 值是同一个，也就是要**保持 timerId 的值在组件更新期间保持不变**。此时，就用到：`useRef` Hook 了。

```js
// 创建 ref 对象
const timerRef = useRef(-1)

useEffect(() => {
  // 将定时器id存储到 ref 对象中
  timerRef.current = setInterval(() => {
    console.log('interval')
  }, 1000)
}, [])

const clear = () => {
  // 从 ref 对象中拿到之前存储的定时器id
  clearInterval(timerRef.current)
}

// 说明：两个地方拿到的 timerRef.current 是同一个对象！
```

### 使用定时器展示倒计时

**目标**：能够使用回调函数形式的setState更新状态

**分析说明**：

对于倒计时的定时器来说，只需要在组件创建时，开启一次即可。为了做到这一点，可以通过 `useEffect(() => {}, [])` 来实现

注意：此处的关键点是依赖项参数为：`[]`（空数组）。因此，不能在 effect 回调函数中，依赖外部的数据

但是，页面中的计数器数值又要更新，因此就会有一个新的问题：如何在不依赖于外部数据的情况下，在 effect 回调中，更新状态？

回答：**使用回调函数形式的setState来更新状态**

```jsx
const [count, setCount] = useState(0)

// 语法一：
setCount(count + 1)

// 语法二：回调形式的更新状态
setCount(prevCount => prevCount + 1)
```

对比以上两种语法的不同点：

```jsx
// 语法一： 依赖外部数据，需要通过 useEffect 的第二个参数指定
useEffect(() => {
  setCount(count + 1)
}, [count])

// 语法二： 不依赖于外部数据，不需要指定 useEffect 的依赖
useEffect(() => {
  setCount(prevCount => prevCount + 1)
}, [])
```

---

## 13-验证码倒计时-开启倒计时

**目标**：能够在点击获取验证码时显示倒计时

**步骤**：

1. 创建状态 timeLeft 倒计时数据
2. 在点击获取验证码的事件处理程序中，更新倒计时时间并开启定时器
3. 在定时器中，更新状态（需要使用回调函数形式的 setTimeLeft）
4. 在开启定时器时，展示倒计时时间

**核心代码**：

pages/Login/index.tsx 中：

```tsx
import { useState } from 'react'

const Login = () => {
  const [timeLeft, setTimeLeft] = useState(0)

  const onGetCode = () => {
    // ...

    settimeLeft(5)
    setInterval(() => {
      // 回调函数形式更新状态
      setTimeLeft(timeLeft => timeLeft - 1)
    }, 1000)
  }

  return (
    // ...
    <Form.Item
      extra={
        <span
          // 判断是否开启定时器，没开启绑定事件，开启后去掉事件
          onClick={timeLeft === 0 ? onGetCode : undefined}
        >
          {/* 判断是否开启定时器，没开启展示 发送验证码，开启后展示倒计时 */}
          {timeLeft === 0 ? '发送验证码' : `${timeLeft}s后重新获取`}
        </span>
      }
    >
    </Form.Item>
  )
}
```

## 14-验证码倒计时-清理定时器

**目标**：能够在倒计时结束时清理定时器

**步骤**：

1. 通过 useRef Hook 创建一个 ref 对象，用来存储定时器 id
2. 在开启定时器时，将定时器 id 存储到 ref 对象中
3. 通过 useEffect Hook 监听倒计时的变化
4. 判断倒计时时间是否为 0 ，如果为 0 就清理定时器
5. 在组件卸载时（点击登录按钮，跳转到首页），清理定时器

```tsx
const timerRef = useRef(-1)

const onGetCode = () => {
  // ...

  // 注意：此处需要使用 window.setInterval
  // 因为 setInterval 默认返回 NodeJS.Timeout，使用 window.setInterval 后，返回值才是 number 类型的数值
  timerRef.current = window.setInterval(() => {
    setTimeLeft(timeLeft => timeLeft - 1)
  }, 1000)
}

// 1. 监听倒计时变化，在倒计时结束时清理定时器
useEffect(() => {
  if (timeLeft === 0) {
    clearInterval(timerRef.current)
  }
}, [timeLeft])

// 2. 在组件卸载时清理定时器
useEffect(() => {
  return () => {
    // 清理定时器
    clearInterval(timerRef.current)
  }
}, [])
```

## TS类型 - unknown
