### vue组件通信方式

1. props / $emit
   父组件通过props的方式向子组件传递数据，而通过$emit 子组件可以向父组件通信。

2. provide/ inject
   概念:
   provide/ inject 是vue2.2.0新增的api, 简单来说就是父组件中通过provide来提供变量, 然后再子组件中通过inject来注入变量。

注意: 这里不论子组件嵌套有多深, 只要调用了inject 那么就可以注入provide中的数据，而不局限于只能从当前父组件的props属性中回去数据

3. ref / refs
   ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个ref 来访问组件的例子:
   四、eventBus
   eventBus  又称为事件总线，在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。

### vue设计模式

vue 中使用了哪些设计模式

1. 工厂模式 - 传入参数即可创建实例 虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode 
2. 单例模式 - 整个程序有且仅有一个实例 vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉 
3. 发布-订阅模式 

### vue2 || vue3

1. vue3相比于vue2性能有了很大的提升
      1. 首次渲染更快
      1. diff算法更快
      1. 内存占用更少
      1. 打包体积更小
2. 有更好的Typescript支持
3. compostion API (组合式api)
4. 在vue2中使用的是选项式api,vue3中使用的是组合式api
   1. 组合式api 的目的是增强,不是取代选项式api,vue3对两种api都支持
   1. 需要强烈支持TS的项目首选组合式api
   1. 需要大量逻辑复用的场景首选组合式api

### vue响应式原理

1. vue2的响应式原理是由Object.defineProperty()实现的 (数据劫持）
2. vue3的响应式原理是由es6中的Proxy所实现的 (数据代理)

### vue-router

1. Vue-Router有两个路由模式，分别是哈希hash模式和历史history模式，然后默认的是哈希hash模式。
2. 原理核心就是 更新视图但不重新请求页面。

### vue性能优化

1. 代码模块化，咱们可以把很多常用的地方封装成单独的组件，在需要用到的地方引用，而不是写过多重复的代码，每一个组件都要明确含义，复用性越高越好，可配置型越强越好，包括咱们的css也可以通过less和sass的自定义css变量来减少重复代码。
2. for循环设置key值，在用v-for进行数据遍历渲染的时候，为每一项都设置唯一的key值，为了让Vue内部核心代码能更快地找到该条数据，当旧值和新值去对比的时候，可以更快的定位到diff。
3. Vue路由设置成懒加载，当首屏渲染的时候，能够加快渲染速度。
4. 更加理解Vue的生命周期，不要造成内部泄漏，使用过后的全局变量在组件销毁后重新置为null。可以使用keep-alive，keep-alive是Vue提供的一个比较抽象的组件，用来对组件进行缓存，从而节省性能。
5. 修改vue.config.js中的配置项，把productionSourceMap设置为false，不然最终打包过后会生成一些map文件，如果不关掉，生成环境是可以通过map去查看源码的，并且可以开启gzip压缩，使打包过后体积变小。
6. 使用cdn的方式外部加载一些资源，比如vue-router、axios等Vue的周边插件，在webpack.config.js里面，externals里面设置一些不必要打包的外部引用模块。然后在入门文件index.html里面通过cdn的方式去引入需要的插件。
7. 减少图片使用，因为对于网页来说，图片会占用很大一部分体积，所以，优化图片的操作可以有效的来加快加载速度。可以用一些css3的效果来代替图片效果，或者使用雪碧图来减少图片的体积。
8. 按需引入，咱们使用的一些第三方库可以通过按需引入的方式加载。避免引入不需要使用的部分，无端增加项目体积。比如在使用element-ui库的时候，可以只引入需要用到的组件。

### vue父子组件生命周期执行顺序

一.vue常用生命周期：

1. beforeCreate: data和el均未初始化，值为undefined
2. created: Vue 实例观察的数据对象data已经配置好，已经可以得到data的值且data已经具有响应式，但Vue 实例使⽤的根 DOM 元素el还未初始化
3. beforeMount: 在模板编译之后,渲染之前触发;data和el均已经初始化，但此时el并没有渲染进数据，el的值为“虚拟”的元素节点
4. mounted: 此时el已经渲染完成并挂载到实例上;
5. beforeUpdate: 数据更新时调⽤,发⽣在虚拟DOM重新渲染和打补丁之前;可以在该⽣命周期中进⼀步的更改状态,不会触发附加的重渲染过程;
6. updated: 在数据改变后,模板改变后触发; 数据更改导致的虚拟DOM重新渲染和打补丁,在这之后调⽤该⽣命周期函数; 调⽤该⽣命周期函数时,组件DOM已经更新,可以执⾏依赖DOM的操作;
7. activated: 使⽤ keep-alive 时调⽤
8. deactivated: 使⽤ keep-alive 时调⽤
9. beforeDestroy: 组件卸载前触发,可以在此时清理事件,计时器或者取消订阅操作;
10. destoryed: 实例销毁之后调⽤; 调⽤后, vue实例指⽰的所有东西都会解除绑定,所有的事件监听器会被⼀处,所有的⼦实例也会被销毁
    ————————————————

二. ⽗⼦组件初始化时 ⽣命周期的执⾏顺序
⽗beforeCreate -> ⽗created -> ⽗beforeMount -> ⼦beforeCreate -> ⼦created -> ⼦beforeMount -> ⼦mounted->⽗mounted
三. ⽗⼦组件数据更新时 ⽣命周期的执⾏顺序
⽗beforeUpdate -> ⼦beforeUpdate -> ⼦updated -> ⽗updated
四. ⽗⼦组件销毁时 ⽣命周期的执⾏顺序
⽗beforeDestroy -> ⼦beforeDestroy -> ⼦destroyed -> ⽗destroyed
————————————————
