### 面试话术

#### 自我介绍

##### v1

面试官你好，我叫xxx，工作时间有x年，熟悉的技能有xxx,做过的项目有xxx,您还有什么想要了解的吗

##### v2

面试官你好，我叫xxx,有两年的工作经验

1. 熟练使用 HTML + CSS JavaScript独立完成静态页面布局
2. 熟练掌握 HTML5、CSS3 新特性
3. 能够灵活运用ES6
4. 熟练使用Vue框架，Vue+Vuex+Vue-router
5. 熟练使用ElementUI组件库进行页面布局
6. 熟练使用移动端弹性布局，百分比布局
7. 熟练掌握webpack前端模块化打包工具
8. 熟练使用Ajax,axios前后端交互技术

##### v3

面试官你好，我叫xxx,有两年的工作经验

1. 熟练使用 HTML + CSS JavaScript独立完成静态页面布局

2. 熟练掌握 HTML5、CSS3 新特性

   1. HTML5新特性
      1. 拖拽释放(Drap and Drop) API ondrop 拖放是一种常见的特性，即抓取对象以后拖到另一个位置 在HTML5中，拖放是标准的一部分，任何元素都能够拖放
      2. 自定义属性 data-id
      3. 语义化更好的内容标签(header,nav,footer,aside,article,section)
      4. 音频，视频(audio,video)如果浏览器不支持自动播放怎么办？在属性中添加autoplay
      5. 画布canvas
         1. getContext() 方法返回一个用于在画布上绘图的环境 Canvas.getCountext(contextID)参数 contextID 指定了您想要在画布上绘制的类型。当前唯一的合法值是"2d"，它指定了二维绘图，并且导致这个方法返回一个环境对象，该对象导出一个二维绘图API
         2. ctx.stroke() 如果没有这一步 线条是不会显示在画布上的
         3. canvas和image的处理图片的时候有什么区别？
            1. image是通过对象的形式描述图片的，canvas通过专门的API将图片绘制在画布上
      6. 地理(Geolocation) API
      7. 本地离线存储 localStorage 长期存储数据 浏览器关闭后数据不丢失
      8. sessionStorage的数据在浏览器关闭后自动删除
      9. 表单控件 calendar,date,time,email,url,search,tel,file,number
      10. 新的技术 webworker,websocket,Geolocation
   2. CSS3新特性
      1. 颜色: 新增 RGBA , HSLA 模式
      2. 文字阴影(text-shadow)
      3. 边框: 圆角(border-radius) 边框阴影 : box-shadow
      4. 盒子模型: box-sizing
      5. 背景:background-size background-origin background-clip
      6. 渐变: linear-gradient , radial-gradient
      7. 过渡 : transition 可实现动画
      8. 自定义动画 animate @keyfrom
      9. 媒体查询 多栏布局 @media screen and (width:800px) {...}
      10. border-image
      11. 2D 转换;transform: translate(x,y) rotate(x,y) skew(x,y) scale(x,y)
      12. 3D 转换
      13. 字体图标 font-face
      14. 弹性布局 flex

3. 能够灵活运用ES6

   1. ES5 || ES6

      1. ES5 指 ECMAScript5，是ECMAScript的第五次修订，于2009年完成标准化
      2. ES6 指 ECMAScript6，是ECMAScript的第六次修订，于2015年完成标准化 也称 ES2015
      3. ES6是继ES5之后的一次改进，相对于ES5更加简洁，提高了开发效率

   2. ES6

      1. 新增声明命令 let 和 count

         1. 在ES6中通常用let和const来声明，let表示变量，count表示常量
         2. let 和 const 都是块级作用域，以{}代码块作为作用域范围，let没有变量提升，const声明的是一个只读常量，在声明的时候就需要赋值，(如果const声明的是一个对象，对象包含的值可以修改，抽象的说，对象所指向的地址不能改变，而成员是可以修改的)

      2. 模板字符串(Template String)

         1. 用一对反引号``标识，它可以当作普通字符串使用，也可以用来定义多行字符串，也可以在字符串中嵌入变量，js表达式或函数，变量、js表达式或函数需要写在${}中

      3. 函数的扩展

         1. 函数-默认参数
         2. 箭头函数
            1. 函数名=（形参）=> {……} 当函数体中只有一个表达式时，{} 和 return 可以省略，当函数体中形参只有一个，() 可以省略

      4. 对象的扩展

         1. 属性的简写：ES6允许在对象之中直接变量。这时，属性名为变量名，属性值为变量的值。
         2. Object.keys()方法：获取对象所有属性名或方法名(不包括原型的内容)，返回一个数组 ，如果是对象则返回key ,(对象={key:value}),如果是数组则返回下标值
         3. Object.assign()：assign方法将多个原对象的属性和方法都合并到了目标对象上面，可以接收多个参数，第一个参数是目标对象，后面的都是源对象

      5. fot ...of 循环 用来遍历值的

         1. ```js
            let arr = ['小林','小吴','小佳']
            for (let i of arr) {
                console.log(i)
            }
            // 小林 小吴 小佳
            ```

      6. import 和 export 

         1. ES6标准中，JavaScript原生支持模块(module)。这种将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用
         2. export 用于对外输出本模块(一个文件可以理解一个模块)变量的接口
         3. improt 用于在一个模块中加载另一个含有export接口的模块
         4. import 和 export 命令只能在模块的顶部，不能在代码块之外

      7. Promise对象

         1. Promise是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数，为了解决异步回调地狱(也就是循环嵌套的问题)而产生的Promise 构造函数包含一个参数和一个带有resolve(解析)和reject(拒绝)两个参数的回调。在回调中执行一些操作(例如异步)，如果一切都正常，则调用resolve，否则调用reject方法作为回调。then()方法接收两个参数：onResolve和onReject，分别当前Promise对象的成功与失败
         2. Promise的3种状态：Fulfilled为成功的状态，Rejected为失败的状态，Pending既不是Fulfilled 也不是Reject的状态 可以理解为Promise对象实例创建时候的初始状态

      8. 解构赋值：是对赋值动算符的扩展，对数组或对象进行模式匹配，对变量赋值

         1. 数组的解构赋值要一一对应，对应不上就是undefined
         2. 对象的解构赋值和数据的类似，但数组的成员都是有序的，对象的属性是无序的，所以对象的解构赋值简单理解是等号左边的右边的结构相同

      9. set数据结构

         1. set数据，类似数组，所有的数据都是唯一的，没有重复的值。它本身是一个构造函数
            1. Set 属性和方法Size() 数据的长度
            2. Add() 添加某个值,返回 Set 结构本身。
            3. Delete() 删除某个值,返回一个布尔值,表示删除是否功。
            4. Has() 查找某条数据,返回一个布尔值。
            5. Clear()清除所有成员,没有返回值。
            6. 主要应用场景:数组去重

      10. class

          1. class类的继承ES6中不再像ES5一样使用原型链实现继承，而是引入class这个概念
          2. ES6 所写的类相比于ES5的优点
             1. 区别于函数，更加专业化(类似于JAVA中的类)
             2. 写法更加简便，更加容易实现类的继承

      11. ... 展开运算符可以将数组或对象里面的值展开;还可以将多个值收集为一个变量

      12. async await

          1. 使用 async/await, 搭配 Promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性 async 用于申明一个 function 是异步的,而 await 用于等待一个异步方法执行完成

      13. 修饰器

          1. @decorator 是一个函数,用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数

      14. Symbol

          1. Symbol 是一种基本类型。Symbol 通过调用 symbol 函数产生,它接收一个可选的名字参数,该函数返回的 symbol 是唯一的

      15. Proxy

          1. Proxy 代理使用代理(Proxy)监听对象的操作,然后可以做一些相应事情

4. 熟练使用Vue框架，Vue+Vuex+Vue-router

   1. vue 可以进行组件化开发，通过复用组件，加快开发效率
   2. vue最突出的优势可以对数据进行双向数据绑定
      1. 双向绑定的原理
   3. 使用vue编写出来的界面效果本身便是响应式的，这使网页在不同设备上都能显出非常好看的效果
      1. 响应式的原理，什么叫响应式数据

5. 熟练使用ElementUI组件库进行页面布局

6. 熟练使用移动端弹性布局，百分比布局

7. 熟练掌握webpack前端模块化打包工具

8. 熟练使用Ajax,axios前后端交互技术



#### 项目

```js
1. 1. 对vue比较熟悉,能利用vuex管理全局数据

   2. 对于组件的封装掌握较好,用到的知识点有nodejs的导入以及导出功能,

   3. 还有,如路由懒加载以及图片懒加载,主要是考虑到用户的所使用的设备不一样,主要是在打包时用的到,考虑到用户群体的条件不一样,所以需要动态加载,也算是优化用户体验了,具体表现为当路由被访问到的时候才加载对应组件,这里因为Vue Router支持开箱即用的动态导入

   4. 目前也在学习vue3相关的知识,因为vue作者尤雨溪在2022年2月7 日宣布,vue3将成为vue的默认版本,所以一直在学习,我简要说一下我的理解吧

      1. vue3相比于vue2性能有了很大的提升

         1. 首次渲染更快
         2. diff算法更快
         3. 内存占用更少
         4. 打包体积更小
         5. 有更好的Typescript支持
         6. compostion API (组合式api)

      2. 在vue2中使用的是选项式api,vue3中使用的是组合式api

         1. 组合式api 的目的是增强,不是取代选项式api,vue3对两种api都支持
         2. 需要强烈支持TS的项目首选组合式api
         3. 需要大量逻辑复用的场景首选组合式api

      3. 定义响应式数据的区别

         1. 在vue2中是在data中定义并return出去

            1. ```js
               data() {
               	reutrn {
                    // 要定义的数据   
                   }
               }
               ```

         2. vue3中定义响应式数据的方法有两种,reactive和ref,推荐用ref,先引入ref 再return 出去;在setup访问,模板中不需要加.value,函数中使用ref结果,需要通过.value

            1. ```js
               import { ref } from 'vue'
               export default {
                   setup() {
                       const state = ref([])
                       return {
                           state
                       }
                   }
               }
               ```


```

