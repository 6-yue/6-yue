## 黑马优购

### 今日目标



### 1. 分类

分类页的路径是 `page/category/index`，在这个页面当中分类被分成了 3 个级别，分别是一级分类、二级分类和品牌，该页面所有的数据是通过一个接口来获取的。

```bash
# 创建分支
git checkout main
git checkout -b feature-category
```

#### 1.1 一级分类

实现步骤：

1. 在 data 中定义一级分类数据（数组类型）
2. 在 onLoad 生命周期函数中调用获取分类数据的方法
3. 在 methods 中定义获取分类数据的方法
4. 添加点击事件设置选中状态

布局代码的结构使用到了 `scroll-view` 组件，被选中状态需要添加 `.active` 类名：

```html
<!-- pages/category/index -->
<view class="sup">
  <scroll-view scroll-y>
    <text class="active">大家电</text>
    <text>热门推荐</text>
    <text>海外购</text>
    <text>苏宁房产</text>
    <text>手机相机</text>
    <text>电脑办公</text>
    <text>厨卫电器</text>
    <text>食品酒水</text>
    <text>居家生活</text>
    <text>厨房电器</text>
  </scroll-view>
</view>
```

定义方法获取分类数据：

```javascript
// pages/category/index.vue
export default {
  data() {
    return {
      // 一级分类数据
      categoryList: [],
    }
  },
  
  methods: {
    // 获取分类数据
    async getCategoryList() {
      // 同步方式获取数据
      const { data: res } = await uni.$http.get('/api/public/v1/categories');
      // 校验数据
      if(res.meta.status !== 200) {
        return uni.showToast({
          title: '数据获取失败!',
          icon: 'none'
        })
      }
      // 更新数据，重新渲染
      this.categoryList = res.message;
    },
  }
}
```

成功获取数据后渲染到模板当中：

```xml
<!-- pages/category/index.vue -->
<view class="sup">
  <scroll-view scroll-y>
    <text
    	v-for="(item, index) in categoryList"
      :key="item.cat_id"
    >
      {{ item.cat_name }}
    </text>
  </scroll-view>
</view>
```

最后添加点击交互，被点击的元素添加 `.active` 类名

```xml
<!-- pages/category/index.vue -->
<view class="sup">
  <scroll-view scroll-y>
    <text
    	v-for="(item, index) in categoryList"
      :key="item.cat_id"
      :class="{ active: activeIndex === index }"
      @click="setActiveIndex(index)"
    >
      {{ item.cat_name }}
    </text>
  </scroll-view>
</view>
```

```javascript
// pages/category/index.vue
export default {
  data() {
    return {
      // 一级分类数据
      categoryList: [],
      // 记录当前点击了哪个一级分类
      activeIndex: 0
    }
  },
  
  methods: {
    // 获取分类数据
    async getCategoryList() {},
    // 点击一级分类
    setActiveIndex(index) {
      // 记当当前点击了哪个一级主分类
      this.activeIndex = index;
    }
  }
}
```

代码编写完成后提交 git 

```bash
# 查看代码修改情况
git status
# 提交代码
git add .
git commit -m '完成一级分类的接口联调'
# 推送到远程仓库
git push origin feature-category
```

#### 1.2 二级分类

实现思路：

分析接口返回数据后可以每个一级分类中包含的 `children` 属性即为对应的二级分类，因此获取一级分类对应的二级分类只需要知道一级分类的索引值即可。

二级分类及品牌的布局代码：

```xml
<!-- pages/category/index.vue -->
<view class="sub">
  <scroll-view scroll-y>
    <!-- 封面图 -->
    <image src="http://static.botue.com/ugo/uploads/category.png" class="thumb"></image>
    <view class="children">
      <view class="title">电视</view>
      <!-- 品牌 -->
      <view class="brands">
        <navigator url="/subpkg/pages/list/index">
          <image src="http://static.botue.com/ugo/uploads/brand_1.jpg"></image>
          <text>曲面电视</text>
        </navigator>
        <navigator url="/subpkg/pages/list/index">
          <image src="http://static.botue.com/ugo/uploads/brand_2.jpg"></image>
          <text>海信</text>
        </navigator>
      </view>
    </view>
    <view class="children">...</view>
  </scroll-view>
</view>
```

Vue 提供的计算属性在此比较适合根据索引的变化来获取相应的二级分类：

```javascript
// pages/category/index.vue
export default {
  data() {
    return {
      // 一级分类数据
      categoryList: [],
      // 记录当前点击了哪个一级分类
      activeIndex: 0
    }
  },
  computed: {
    // 根据索引的变化动态获取二级分类
    subCategoryList() {
      // 检测是否存在一级分类
      if (this.categoryList[this.activeIndex]) {
        return this.categoryList[this.activeIndex].children;
      }
      return [];
    }
  },
  methods: {
    // 获取分类数据
    async getCategoryList() {},
    // 点击一级分类
    setActiveIndex(index) {
      // 记当当前点击了哪一级主分类
      this.activeIndex = index;
    }
  }
}
```

计算属性 `subCategoryList` 即为二级分类数据，将其渲染到模板当中：

```xml
<!-- pages/category/index.vue -->
<view class="sub">
  <scroll-view scroll-y>
    <!-- 封面图 -->
    <image src="http://static.botue.com/ugo/uploads/category.png" class="thumb"></image>
    <view class="children" v-for="item in subCategoryList" :key="item.cat_id">
      <view class="title">{{ item.cat_name }}</view>
      <!-- 品牌 -->
      <view class="brands">
        <navigator
           v-for="brand in item.children"
           :key="brand.cat_id"
           :url="`/subpkg/pages/list/index?query=${brand.cat_name}`">
          <image :src="brand.cat_icon"></image>
          <text>{{ brand.cat_name }}</text>
        </navigator>
      </view>
    </view>
  </scroll-view>
</view>
```

代码编写完成后提交 git 

```bash
# 查看代码修改情况
git status;
# 提交代码
git add .
git commit -m '完成二级分类的接口联调'
# 推送到远程仓库
git push origin feature-category
# 本地合并到 main/master 分支
git checkout main
git merge feature-category
```

### 2. 搜索

搜索功能是一个公共的组件位于 `components/search/index.vue` 中。

```bash
# 创建分支
git checkout main
git checkout -b feature-search
```

#### 2.1 布局及交互分析

该组件中事先定义好了一些交互，我们先来熟悉一下：

```xml
<!-- components/search/index.vue -->
<!-- 搜索框 -->
<view class="input-wrap" @click="goSearch">
  <input class="input" type="text" :placeholder="placeholder" />
  <text class="cancle" @click.stop="cancleSearch">取消</text>
</view>
```

```javascript
// components/search/index.vue
export default {
  data() {
    return {
      // 是否显示搜索弹层
      focused: false,
      // 输入框提示文件
      placeholder: ''
    };
  },
  methods: {
    goSearch(ev) {
      // 显示搜索弹层
      this.focused = true;
      // 设置搜索框提示
      this.placeholder = '请输入您要搜索的内容';
      
      // 省略以下部分代码...
    },
    cancleSearch() {
      // 隐藏搜索弹层
      this.focused = false;
      // 清空搜索框提示
      this.placeholder = '';
      
      // 省略以下部分代码...
    }
  }
};
```

#### 2.2 关键字搜索

当用户在表单中输入关键字时，调用接口获取数据并进行展示。

搜索结果布局结构如下：

```xml
<scroll-view scroll-y class="result">
  <navigator class="navigator" url="/subpkg/pages/goods/index">小米</navigator>
  <navigator class="navigator" url="/subpkg/pages/goods/index">小米</navigator>
  <navigator class="navigator" url="/subpkg/pages/goods/index">小米</navigator>
</scroll-view>
```

实现思路：

1. 通过 `v-model` 获取表单数据,[input](https://uniapp.dcloud.io/component/input.html)

```xml
<!-- components/category/index.vue -->
<!-- 搜索框 -->
<view class="input-wrap" @click="goSearch">
  <input class="input" type="text" v-model="query" :placeholder="placeholder" />
  <text class="cancle" @click.stop="cancleSearch">取消</text>
</view>
```

```javascript
<!-- components/category/index.vue -->
export default {
  data() {
    return {
      focused: false,
      placeholder: ''
      // 获取表单中输入的关键字
      query: ''
    }
  },
  methods: {
    goSearch(ev) {},
    cancleSearch() {}
  }
}
```

2. 监听用户输入事件（inut事件）

```xml
<!-- components/category/index.vue -->
<view class="input-wrap" @click="goSearch">
  <input
    class="input"
    type="text"
    v-model="query"
    @input="searchQuery"
  	:placeholder="placeholder" />
  <text class="cancle" @click.stop="cancleSearch">取消</text>
</view>
```

3. 根据输入的关键字调用接口获取数据

```javascript
<!-- components/category/index.vue -->
export default {
  data() {
    return {
      focused: false,
      placeholder: ''
      // 获取表单中输入的关键字
      query: '',
      // 搜索的结果
      searchList: []
    }
  },
  methods: {
    goSearch(ev) {},
    cancleSearch() {},
    // 监听用户的输入
    async searchQuery() {
      // 如果表单的值为空，则不发起请求
      if(this.query.trim().length === 0) return this.searchList = []
      // 同步方式获取数据
      const {data: res} = await uni.$http.get('/api/public/v1/goods/qsearch', {
        // 请求的参数
        query: this.query
      });
      // 校验数据
      if(res.meta.status !== 200) {
        return uni.showToast({
          title: '数据获取失败!',
          icon: 'none'
        })
      }
      // 更新数据，重新渲染
      this.searchList = res.message;
    }
  }
}
```

4. 成功获取数据后渲染到模板当中

```xml
<!-- components/category/index.vue -->
<scroll-view scroll-y v-if="searchList.length" class="result">
  <navigator
    v-for="item in searchList"
    :key="item.goods_id"
    class="navigator"
    :url="`/subpkg/pages/goods/index?id=${item.goods_id}`"
  >
    {{ item.goods_name }}
  </navigator>
</scroll-view>
```

代码编写完成后提交 git 

```bash
# 查看代码修改情况
git status
# 提交代码
git add .
git commit -m '完成关键字搜索功能'
# 推送到远程仓库
git push origin feature-search
```

#### 2.3 防抖处理

用户在表单中输入会持续不断的发起请求，然而并不所有的请求都有意义同时对性也会产生一些负担，这种情况通过采用防抖的方式来处理。

1. 安装 [lodash](https://www.lodashjs.com/) 工具库

```bash
npm install lodash
```

2. 导入 `debounce` 创建防抖函数

```javascript
<!-- components/category/index.vue -->
import {debounce} from 'lodash';

export default {
  data() {
    return {
      focused: false,
      placeholder: ''
      query: '',
      searchList: []
    }
  },
  methods: {
    goSearch(ev) {},
    cancleSearch() {},
    async searchQuery() {}
  }
}
```

给 `debounce`传入一个函数做为参数，它会返回一个新函数，这个函数就是我们需要的防抖函数了。

```javascript
<!-- components/category/index.vue -->
import {debounce} from 'lodash';

export default {
  data() {
    return {
      focused: false,
      placeholder: ''
      query: '',
      searchList: []
    }
  },
  methods: {
    goSearch(ev) {},
    cancleSearch() {},
    // 防抖处理
    searchQuery: debounce(async function() {
      // 如果表单的值为空，则不发起请求
      if(this.query.trim().length === 0) return this.searchList = []
      // 同步方式获取数据
      const {data: res} = await uni.$http.get('/api/public/v1/goods/qsearch', {
        // 请求的参数
        query: this.query
      });
      // 校验数据
      if(res.meta.status !== 200) {
        return uni.showToast({
          title: '数据获取失败!',
          icon: 'none'
        })
      }
      // 更新数据，重新渲染
      this.searchList = res.message;
    }, 500),
  }
}
```

代码编写完成后提交 git 

```bash
# 查看代码修改情况
git status;
# 提交代码
git add .
git commit -m '优化搜索防抖处理'
# 推送到远程仓库
git push origin feature-search
```

#### 2.4 搜索历史

记录用户搜索的内容。

搜索历史布局结构为：

```xml
<!-- components/category/index.vue -->
<view class="history">
  <navigator class="navigator" url="/subpkg/pages/list/index">小米</navigator>
  <navigator class="navigator" url="/subpkg/pages/list/index">智能电视</navigator>
</view>
```

实现思路：

1. 监听 `confirm` 事件（用户点击手机键盘搜索键或者电脑的回车键）

```xml
<!-- components/category/index.vue -->
<view class="input-wrap" @click="goSearch">
  <input
    class="input"
    type="text"
    v-model="query"
    @input="searchQuery"
    @confirm="addHistory"
  	:placeholder="placeholder" />
  <text class="cancle" @click.stop="cancleSearch">取消</text>
</view>
```

2. 初始 `queryHistory` 数据记录用户输入的历史

```javascript
// components/search/index.vue
import {debounce} from 'lodash';

export default {
  data() {
    return {
      focused: false,
      placeholder: ''
      query: '',
      searchList: [],
      // 搜索历史
      queryHistory: []
    }
  },
  methods: {
    goSearch(ev) {},
    cancleSearch() {},
    // 防抖处理
    searchQuery: debounce(async function() {
      // ...
    }, 500),
    // 记录搜索历史
    addHistory() {
      // 如果有重复搜索的关键字，不再重复记录
      if(this.queryHistory.includes(this.query)) return;
      // 将搜索的内容记录到数组中
      this.queryHistory.push(this.query);
    }
  }
}
```

3. 将记录的历史数据渲染到页面当中

```xml
<!-- components/category/index.vue -->
<view class="history">
  <navigator
  	class="navigator"
    v-for="item in historyQuery"
    :key="item"
    :url="`/subpkg/pages/list/index?query=${item}`">
    {{ item }}
  </navigator>
</view>
```

此处优化一个交互功能：当用户取消搜索时将输入框中的关键字及搜索结果清空。

```javascript
// components/search/index.vue
import {debounce} from 'lodash';

export default {
  data() {
    return {
      // ...
    }
  },
  methods: {
    cancleSearch() {
      // 隐藏搜索弹层
      this.focused = false;
      // 清空搜索框提示
      this.placeholder = '';
      
      // 重置搜索
      this.query = '';
      this.searchList = [];
      
      // 省略以下部分代码...
    },
    goSearch(ev) {},
    cancleSearch() {},
    // 防抖处理
    searchQuery: debounce(async function() {}, 500),
    // 记录搜索历史
    addHistory() {}
  }
}
```

代码编写完成后提交 git 

```bash
# 查看代码修改情况
git status
# 提交代码
git add .
git commit -m '记录搜索的历史'
# 推送到远程仓库
git push origin feature-search
```

#### 2.5 本地存储

上述步骤中所记录的搜索历史是记录在变量当中的，当下次重新打开页面数据就会丢失，为了能够长久的保存，本节我们将搜索历史记录到小程序的本地存储当中。

小程序提供了 API 用于在本地存储数据，分别为 `uni.setStorageSync` 和 `uni.getStorageSync` 一个用于存入数据，一个用于读取数据。

注：小程序的本地址存储可以直接存入对象类型的数据，不需要 `JSON.stringify` 处理成字符串。

```javascript
// components/search/index.vue
import {debounce} from 'lodash';

export default {
  data() {
    return {
      focused: false,
      placeholder: ''
      query: '',
      searchList: [],
      // 搜索历史
      queryHistory: []
    }
  },
  methods: {
    goSearch(ev) {},
    cancleSearch() {},
    // 防抖处理
    searchQuery: debounce(async function() {
      // ...
    }, 500),
    // 记录搜索历史
    addHistory() {
      // 如果有重复搜索的关键字，不再重复记录
      if(this.queryHistory.includes(this.query)) return;
      // 将搜索的内容记录到数组中
      this.queryHistory.push(this.query);
      // 将搜历史存入本地
      uni.setStorageSync('history', this.queryHistory);
    }
  }
}
```

每次新打开搜索组件时从本地存储中读取历史数据

```javascript
// components/category/index.vue
import {debounce} from 'lodash';

export default {
  data() {
    return {
      focused: false,
      placeholder: ''
      query: '',
      searchList: [],
      // 搜索历史，初始值从本地中读取
      queryHistory: uni.getStorageSync('history') || []
    }
  },
  methods: {
    goSearch(ev) {},
    cancleSearch() {},
    // 防抖处理
    searchQuery: debounce(async function() {
      // ...
    }, 500),
    // 记录搜索历史
    addHistory() {
      // 如果有重复搜索的关键字，不再重复记录
      if(this.queryHistory.includes(this.query)) return;
      // 将搜索的内容记录到数组中
      this.queryHistory.push(this.query);
      // 将搜历史存入本地
      uni.setStorageSync('history', this.queryHistory);
    }
  }
}
```

代码编写完成后提交 git 

```bash
# 查看代码修改情况
git status
# 提交代码
git add .
git commit -m '将搜索历史记录在本地'
# 推送到远程仓库
git push origin feature-search
```

#### 2.6 清空历史

用户可以自行将搜索历史给清空掉，删除本地存储使用 `uni.removeStorageSync`。

清空搜索历史的布局结为：

```xml
<!-- components/search/index.vue -->
<view class="title">
  搜索历史
  <text class="clear"></text>
</view>
```

实现思路：

1. 添加点击事件

```xml
<!-- components/search/index.vue -->
<view class="title">
  搜索历史
  <text class="clear" @click="removeHistory"></text>
</view>
```

2. 清空历史数据

```javascript
// components/category/index.vue
import {debounce} from 'lodash';

export default {
  data() {
    return {
      focused: false,
      placeholder: ''
      query: '',
      searchList: [],
      // 搜索历史，初始值从本地中读取
      queryHistory: uni.getStorageSync('history') || []
    }
  },
  methods: {
    goSearch(ev) {},
    cancleSearch() {},
    // 防抖处理
    searchQuery: debounce(async function() {
      // ...
    }, 500),
    addHistory() {},
    // 清空历史数据
    removeHistory() {
      // 调用 api 删除本地存储中的 history 数据
      uni.removeStorageSync('history');
      // 更新数据，重新渲染
      this.queryHistory = []
    }
  }
}
```

代码编写完成后提交 git 

```bash
# 查看代码修改情况
git status
# 提交代码
git add .
git commit -m '将搜索历史记录在本地'
# 推送到远程仓库
git push origin feature-search

# 合并到本地 main/master 分支
git checkout main
git merge feature-search
```

### 3. 商品列表

商品列表页的页面的路径是 `subpkg/pages/list/index` ，在该页面根据地址参数查询获取相应的商品列表。

```bash
# 创建分支
git checkout main
git checkout -b feature-list
```

#### 3.1 获取地址参数

在开发前面功能时有许多地方是可以通过链接的方式跳转到商品列表页面的，当时我们统一指定了地址参数 `query`，在商品列表页中获取这个参数的值，然后根据这个值调用接口获取数据。

```javascript
// subpkg/pages/list/index.vue
export default {
  data() {
  	return {
  		// ...
      query: ''
		}
	},
 	// 在生命周期 onLoad 中获取地址中的参数
  onLoad(params) {
    this.query = params.query;
  }
}
```

在小程序生命周期 `onLoad` 中获取地址上的参数。

#### 3.2 查询商品列表

商品列表布局结构代码如下所示：

```xml
<!-- subpkg/pages/list/index.vue -->
<scroll-view class="goods" scroll-y>
  <view class="item" @click="goDetail">
    <!-- 商品图片 -->
    <image class="pic" src="http://static.botue.com/ugo/uploads/goods_1.jpg"></image>
    <!-- 商品信息 -->
    <view class="meta">
      <view class="name">【海外购自营】黎珐(ReFa) MTG日本 CARAT铂致V脸美容仪 【保税仓发货】</view>
      <view class="price">
        <text>￥</text>1399<text>.00</text>
      </view>
    </view>
  </view>
  <view class="item" @click="goDetail">...</view>
</scroll-view>
```

实现思路：

1. 检测地址参数据是否合法

```javascript
// subpkg/pages/list/index.vue
export default {
  data() {
  	return {
  		// 商品列表
      goodsList: [],
      query: ''
		}
	},
 	// 在生命周期 onLoad 中获取地址中的参数
  onLoad(params) {
    this.query = params.query;
    // 调用接口
    this.getGoodsList();
  },
  methods: {
    getGoodsList(query) {
      // 地址中参数据不合法
      if(!this.query) return;
    }
  }
}
```

2. 调用接口获取数据

```javascript
// subpkg/pages/list/index.vue
export default {
  data() {
  	return {
  		// 商品列表
      goodsList: [],
      query: '',
      // 提示信息
      msg: ''
		}
	},
 	// 在生命周期 onLoad 中获取地址中的参数
  onLoad(params) {
    this.query = params.query;
    // 调用接口
    this.getGoodsList();
  },
  methods: {
    async getGoodsList(query) {
      // 地址中参数据不合法
      if(!this.query) return;
      
      // 同步方式获取数据
      const {data: res} = await uni.$http.get('/api/public/v1/goods/search', {
        query: this.query,
        pagenum: 1,
        pagesize: 5
      })
      // 校验数据
      if(res.meta.status !== 200) return uni.$showToast();
      // 更新数据，重新渲染
      this.goodsList = res.message.goods;
      
      // 请求结束后再显示提示信息
      if(this.goodsList.length === 0) this.msg = '空空如也～';
    }
  }
}
```

3. 将数据渲染到页面当中

```xml
<!-- subpkg/pages/list/index.vue -->
<scroll-view class="goods" scroll-y>
  <view class="item" v-for="item in goodsList" :key="item.goods_id" @click="goDetail">
    <!-- 商品图片 -->
    <image class="pic" :src="item.goods_small_logo"></image>
    <!-- 商品信息 -->
    <view class="meta">
      <view class="name">{{item.goods_name}}</view>
      <view class="price">
        <text>￥</text>{{item.goods_price}}<text>.00</text>
      </view>
    </view>
  </view>
  <!-- 没有数据提示信息 -->
  <view class="tips">{{msg}}</view>
</scroll-view>
```

代码编写完成后提交 git 

```bash
# 查看代码修改情况
git status
# 提交代码
git add .
git commit -m '完成商品列表接口联调'
# 推送到远程仓库
git push origin feature-list
```

#### 3.3 上拉分页加载

商品列表布局结构用到了组件 [`scroll-view`](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html) ，该组件能够监听到其内容是否滚动到了底部，监听这个事件就可以实现上拉加载分页请求更多数据了。

实现思路：

1. 监听滚动的状态

```xml
<!-- subpkg/pages/list/index.vue -->
<scroll-view class="goods" scroll-y @scrolltolower="getMore">
  <view class="item" v-for="item in goodsList" :key="item.goods_id" @click="goDetail">
    <!-- 商品图片 -->
    <image class="pic" :src="item.goods_small_logo"></image>
    <!-- 商品信息 -->
    <view class="meta">
      <view class="name">{{item.goods_name}}</view>
      <view class="price">
        <text>￥</text>{{item.goods_price}}<text>.00</text>
      </view>
    </view>
  </view>
  <!-- 加载更多 -->
  <view class="getMore">正在加载...</view>
</scroll-view>
```

```javascript
// subpkg/pages/list/index.vue
import { debounce } from 'lodash';
export default {
  data() {
  	return {
  		// 商品列表
      goodsList: [],
      query: '',
      msg: ''
		}
	},
 	// 在生命周期 onLoad 中获取地址中的参数
  onLoad(params) {
    this.query = params.query;
    // 调用接口
    this.getGoodsList();
  },
  methods: {
    async getGoodsList(query) {},
    // 监听是否滚动到底部了
    getMore: debounce(function () {
      console.log('到底了...')
    }, 500)
  }
}
```

2. 更新页码，重新获取数据

```javascript
// subpkg/pages/list/index.vue
import { debounce } from 'lodash';
export default {
  data() {
  	return {
  		// 商品列表
      goodsList: [],
      query: '',
      msg: ''
      // 下一页页码
      nextPage: 1
		}
	},
 	// 在生命周期 onLoad 中获取地址中的参数
  onLoad(params) {
    this.query = params.query;
    // 调用接口
    this.getGoodsList();
  },
  methods: {
    async getGoodsList(query) {
      // 地址中参数据不合法
      if(!this.query) return;
      // 同步方式获取数据
      const {data: res} = await uni.$http.get('/api/public/v1/goods/search', {
        query: this.query,
        // 动态指定页码
        pagenum: this.nextPage++,
        pagesize: 5
      })
      // 校验数据
      if(res.meta.status !== 200) {
        return uni.showToast({
          title: '获取数据失败!',
          icon: 'none'
        })
      };
      // 更新数据，重新渲染
      this.goodsList = res.message.goods;
      
      // 请求结束后再显示提示信息
      if(this.goodsList.length === 0) this.msg = '空空如也～';
    },
    // 监听是否滚动到底部了
    getMore: debounce(function () {
      // 调用接口
      this.getGoodsList()
    }, 500)
  }
}
```

3. 将新获取的数据渲染，将新请求的数据合并到上一次请求数据中

```javascript
// subpkg/pages/list/index.vue
import { debounce } from 'lodash';
export default {
  data() {
  	return {
  		// 商品列表
      goodsList: [],
      query: ''
      msg: ''
      // 下一页页码
      nextPage: 1
		}
	},
 	// 在生命周期 onLoad 中获取地址中的参数
  onLoad(params) {
    this.query = params.query;
    // 调用接口
    this.getGoodsList();
  },
  methods: {
    async getGoodsList(query) {
      // ...省略部分代码
      
      // 更新数据，重新渲染
      //this.goodsList = res.message.goods;
      this.goodsList = this.goodsList.concat(res.message.goods);
      
      // 请求结束后再显示提示信息
      if(this.goodsList.length === 0) this.msg = '空空如也～';
    },
    // 监听是否滚动到底部了
    getMore: debounce(function () {
      // 调用接口
      this.getGoodsList()
    }, 500)
  }
}
```

4. 检测还有没有更多数据，调用接口所返回的数据格式为:

```json
{
  message: {
    total: 13,
		pagenum: 1,
    goods: []
  },
  meta: {msg: '获取成功!', status: 200}
}
```

其中 `total` 表示的是数据总共的数量，**页面中 this.goodsList.length 小于 `total` 的值时表明还有更多数据。**

```javascript
// subpkg/pages/list/index.vue
import { debounce } from 'lodash';
export default {
  data() {
  	return {
  		// 商品列表
      goodsList: [],
      query: '',
      msg: '',
      // 下一页页码
      nextPage: 1,
      hasMore: true
		}
	},
 	// 在生命周期 onLoad 中获取地址中的参数
  onLoad(params) {
    this.query = params.query;
    // 调用接口
    this.getGoodsList();
  },
  methods: {
    async getGoodsList(query) {
      // 没有更多数据了...
      if(!this.hasMore) return;
      
      // 地址中参数据不合法
      if(!this.query) return;
      // 同步方式获取数据
      const {data: res} = await uni.$http.get('/api/public/v1/goods/search', {
        query: this.query,
        // 动态指定页码
        pagenum: this.nextPage++,
        pagesize: 5
      })
      // 校验数据
      if(res.meta.status !== 200) {
        return uni.showToast({
          title: '数据获取失败!',
          icon: 'none'
        })
      }
      // 更新数据，重新渲染
      this.goodsList = this.goodsList.concat(res.message.goods);
      // 是否有更多数据
      this.hasMore = this.goodsList.length < res.message.total;
      
      // 请求结束后再显示提示信息
      if(this.goodsList.length === 0) this.msg = '空空如也～';
    },
    // 监听是否滚动到底部了
    getMore: debounce(function () {
      // 调用接口
      this.getGoodsList()
    }, 500)
  }
}
```

```xml
<!-- subpkg/pages/list/index.vue -->
<!-- 加载更多 -->
<view class="getMore" v-if={{hasMore}}>正在加载...</view>
```

代码编写完成后提交 git 

```bash
# 查看代码修改情况
git status
# 提交代码
git add .
git commit -m '完成商品列表上拉加载的功能'
# 推送到远程仓库
git push origin feature-list

# 合并到本地 main/master 分支
git checkout main
git merge feature-list
```

### 4. 商品详情

商品详情页的路径是 `subpkg/pages/goods/index`，跳转到这个路径时必须要带一个参数 id ，根据这个 id 来获取商品的详细信息。 

#### 4.1 获取地址参数

通过 onLoad 生命周期获取地址中的参数

```javascript
// subpkg/pages/goods/index.vue
export default {
  data() {
    return {
      // 初始商品id的值
      goods_id: null
    }
  },
  onLoad(params) {
    // 获取商品的 id
    this.goods_id = params.id
  },
  methods: {
    goCart() {},
    createOrder() {}
  }
}
```

#### 4.2 查询商品详情

调用接口获取商品详情的数据并渲染到页面当中。

```javascript
// subpkg/pages/goods/index.vue
export default {
  data() {
    return {
      // 初始商品id的值
      goods_id: null,
      goodsDetail: {}
    }
  },
  onLoad(params) {
    // 获取商品的 id
    this.goods_id = params.id
  },
  methods: {
    goCart() {},
    createOrder() {},
    // 获取商品详情
    async getGoodsDetail() {
      // 同步方式获取数据
      const { data: res } = await uni.$http.get('/api/public/v1/goods/detail', {
        // 传递参数
        goods_id: this.goods_id
      });
      // 校验数据
      if (res.meta.status !== 200) {
        return uni.showToast({
          title: '获取数据失败!',
          icon: 'none'
        });
      }
      // 更新数据，重新渲染
      this.goodsDetail = res.message;
    }
  }
}
```

成功获取数据后将数据渲染到页面当中：

```xml
<!-- 商品图片 -->
<swiper
  class="pics"
  indicator-dots
  indicator-color="rgba(255, 255, 255, 0.6)"
  indicator-active-color="#fff"
  <swiper-item v-for="item in goodsDetail.pics" :key="item.pics_id">
		<image :src="item.pics_sma_url"></image>
	</swiper-item>
</swiper>
<!-- 基本信息 -->
<view class="meta">
  <view class="price">￥{{goodsDetail.goods_price}}</view>
  <view class="name">{{{{goodsDetail.goods_name}}}}</view>
  <view class="shipment">快递: 免运费</view>
  <text class="collect icon-star">收藏</text>
</view>
```

#### 4.3 富文本展示

 小程序正常情况下是无法兼容 html 标签的，富文本常规情况都是以 html 标签的方式存在的，小程序中提供了一个组件 [rich-text](https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html)，其语法如下：

```xml
<rich-text nodes={{'<h1>Hello World!</h1>'}}></rich-text>
```

`h1` 标签可以正常在小程序中被解析了，如果是原生开发则使用 `rich-text` 但基于 uni-app 开发的情况下可以使用 `v-html` 指令，它会被自动解析成 `rich-text` 。

商品详情就是富文件的内容，因此我们使用  `v-html` 指令来处理它：

```xml
<!-- 商品详情 -->
<view class="detail">
	<view v-html="goodsDetail.goods_introduce"></view>
</view>
```

#### 4.3 联系客服

小程序内置提供了客服务功能，通过 [button](https://developers.weixin.qq.com/miniprogram/dev/component/button.html) 组件来调用这个功能：

```xml
<!-- 必须指定 open-type 且值为 contact 时会打开客服功能 -->
<button open-type="contact">联系客服</button>
```

在小程序管理后台可以进行消息的查看和回复功能。 ![](./images/img-1.png)

### 5. Vant 组件

uni-app 支持使用小程序原生组件，Vant 提供的小程序版的组件就是原生的小程序组件。[Vant Weapp](https://ext.dcloud.net.cn/plugin?id=100)

1. 建立 `wxcomponents` 目录，用于放置小程序原生组件，Vant 就是原生小程序组件

我们从[官网下载](https://github.com/youzan/vant-weapp/releases) Vant 组件，解压缩后将 dist 文件夹拷贝到 `wxcomponents` 目录中，为了方便使用我们将 dist 目录重命名为 weapp 并把它放到 `@vant` 文件夹中（这样做的目录是让目录与官方文档保持一致）。

2. 通过  `usingComponents` 注册全局的组件（也可以页面注册）

```json
{
  "globalStyle": {
    "navigationBarBackgroundColor": "#ea4451",
    "navigationBarTitleText": "黑马优购",
    "usingComponents": {
      "van-button": "/wxcomponents/@vant/weapp/button/index"
    }
  }
}
```

